This part of the project documentation focuses on a **learning-oriented** approach.
You'll get started with the code in this project.

# <center> Finance Machine Learning: Meta-Labeling Application </center>

<center> **Renan Delgado Camur√ßa Lima**

June 30 2023 <br>
renandcl@ita.br <br> </center>

## Introduction

### Overview

In this material you will find a brief introduction to the Meta-Labeling application.
By the end of this tutorial, you will be able to:

- Execute a feature engineering and comprehend chronologically sampling the time series.

- Apply labeling techniques with Bollinger Bands, MADC and Triple Barrier Method.

- Understand the Meta-Labeling application and its advantages.

This example can be reproduced in the juptyer notebook [meta_labeling_tutorial](
    \tutorial\meta_labeling_tutorial.ipynb).

### Context

Recent researches started to use artificial intelligence and machine learning
techniques in asset pricing and market trend forecasting to increase investment
profitability [[1]](#1). Nevertheless, the use of machine learning techniques in
 financial markets is still a challenge, due to variables complexity and noise
 signals, and strategies have been developed to deal with this problem, such as
  the use of labeling techniques, which are used to identify the trading
  opportunities in the data [[2]](#2).

In addition to the labeling techniques, the use of meta-labeling techniques is
also a powerful to improve the performance of machine learning models.
Meta-labeling is a technique that uses the output of a primary model to generate
a new label for the data, which is used to train a secondary model [[3]](#3).
This technique seeks to maximize the model's recall (capturing correctly all positive
trading opportunities) as well as its precision (minimizing the false positive
rate)[[4]](#4).

### Objective

This work aims to analyze the chronological sampling statistical characteristics, the
performance of some labeling techniques in the stock market, and investigate the
potential benefit of meta-learning techniques when combined with these techniques.

## Feature Engineering

Feature engineering is the process of transforming raw data into features that
better represent the underlying problem to the predictive models, resulting in
improved model accuracy on unseen data. On financial markets, the data is usually
time series that represent the price stock and aggregated into bars which
represents its volatility on a given period of time.

Although the labeling techniques aggregate information to the data, some pitfall can
occur depending on the technique on chronological sampling [[3]](#3). Normally, the
time bars are, nonetheless, market do don process information at a constant
interval [[4]](#4).

Moreover, time bars generally exhibit poor statistical properties. To mitigate it,
it can be applied some other strategy, as volume and dollar bars, which tend to
exhibit more stable sampling and its returns are more normally distributed [[5]](#5).

On this analysis, we will use the following features:

- **Close**: The adjusted closing price of the stock.
- **Volume**: The number of shares traded in a day.
- **Label**: Labels generated by the labeling techniques long or short positions.


### Time Series Data

The data used in this example is from a company listed on the US stock market. On
this exploratory process, IBM stocks has been selected for data comprehensions purpose.

```python
>>> import pandas as pd
>>> data = pd.read_csv(f"../../data/data.csv")
>>> data.head()
	open	low	high	close	adj_close	volume	shares_outstanding
date
2002-12-31	73.71	73.71	75.01	74.09	42.94	8233484	    1.804664e+09
2003-01-02	75.33	74.75	77.03	77.03	44.64	8226267	    1.804664e+09
2003-01-03	77.15	76.68	78.06	78.06	45.24	6236566	    1.804664e+09
2003-01-06	78.30	78.21	81.07	79.91	46.32	8285680	    1.804664e+09
2003-01-07	80.26	80.07	82.39	82.22	47.65	12454617	1.804664e+09
```

Plotting the time series for the adjusted close values and volume traded:

```python
>>> import matplotlib.pyplot as plt  # noqa: E402
>>> import numpy as np  # noqa: E402
>>> plt.figure(figsize=(9, 3))
>>> data["adj_close"].plot(
...     legend=True,
...     title="IBM Time Series",
...     xlabel="Date",
...     ylabel="Price",
...     label="Close price",
... )
>>>
>>> data["volume"].plot(
...     secondary_y=True,
...     alpha=0.3,
...     yticks=np.arange(0, 5e8, 1e8),
...     legend=True,
...     label="Volume",
...     ylabel="Volume",
...     )
>>> plt.show()
```

![stock_series](images/stock_series.png)

### Chronological Sampling

The aggregation on bars have some advantages, such as the reduction of the noise on
the data, and the reduction of the computational cost. However, it can also have
some disadvantages, such as the loss of information, and the loss of the
chronological order [[5]](#5).

Therefore, it will be performed a comparison between on common aggregation
technique, the time bars, volume bars and the dollar bars.

#### Bars Aggregation

```python
>>> from fico.chronologicalsampling import dollar_bars, time_bars, volume_bars
>>> data["date"] = pd.to_datetime(data["date"])
>>> data = data.set_index("date")
>>> close = data["adj_close"]
>>> volume = data["volume"]
>>> time_bars_ohlc = time_bars(close, time_range="3d")
>>> dollar_bars_ohlc = dollar_bars(volume, close, dollar_amount=1e9)
>>> volume_bars_ohlc = volume_bars(volume, close, traded_volume=1.2e7)
>>> volume_bars_ohlc.tail()
             close                            volume
              open    high     low   close    volume
date
2023-03-14  124.65  124.65  124.65  124.65   8103883
2023-03-15  123.28  124.70  123.28  124.70  12387764
2023-03-17  123.69  123.69  123.69  123.69  37339906
2023-03-20  125.94  126.57  124.05  124.05  11928331
2023-03-23  123.37  129.31  123.37  129.31  14951189
```

The volume bars are generated by counting the number of shares traded in a given time interval. The dollar bars are generated by counting the total dollar amount of shares traded in a given time interval. The time bars are generated by observations in a given time interval.

The aggregation on bars have some advantages, such as the reduction of the noise on the data, and the reduction of the computational cost. However, it can also have some disadvantages, such as the loss of information, and the loss of the chronological order. For evaluating the noise reduction, the volatility of the data will be evaluated.

#### Frequency Trend Plot

```python
>>> time_bars_price = time_bars_ohlc.loc[:, "close"]
>>> time_bars_ret = np.log(time_bars_price.close / time_bars_price.close.shift(1)).dropna()
>>> dollar_bars_price = dollar_bars_ohlc.loc[:, "close"]
>>> dollar_bars_ret = np.log(
...     dollar_bars_price.close / dollar_bars_price.close.shift(1)).dropna()
>>>
>>> volume_bars_price = volume_bars_ohlc.loc[:, "close"]
>>> volume_bars_ret = np.log(
...     volume_bars_price.close / volume_bars_price.close.shift(1)).dropna()
>>>
>>> info_freq = pd.DataFrame(
...     index=data.index,
...     data={
...         "time_bars": time_bars_ret,
...         "dollar_bars": dollar_bars_ret,
...         "volume_bars": volume_bars_ret,
...         },
...     )
>>>
>>> info_freq = (info_freq > 0).astype(int)
>>> info_freq.groupby([info_freq.index.year, info_freq.index.month],
...     ).agg("sum").rolling(15).mean(
...     ).plot(figsize=(9, 3),title="Trend frequency of observations per month")
>>> plt.show()
```
![frequency_trend](images/freq.png)

The previous plot shows the aggregated data on months for each aggregation technique.
An observation on these plots are that the volume bars vary more than the other bars,
nonetheless, the dollar bars tend to follow the volume bars. This could be more
investigated, however, it could mean a value change on stock price following the
trend of volume change.

On the following plot, the volatility of the data is evaluated. The volatility is
calculated by the standard deviation of the returns of the data. The returns are
calculated by the difference between the adjusted close values of the data.

#### Density Plot

```python
>>> import seaborn as sns
>>> bin_len = 0.001
>>> plt.hist(
...     time_bars_ret,
...     bins=np.arange(min(time_bars_ret), max(time_bars_ret) + bin_len, bin_len),
...     label="time bars",
...     alpha=0.5,
...     density=True,
...     )
>>> plt.hist(
...     dollar_bars_ret,
...     bins=np.arange(min(dollar_bars_ret), max(dollar_bars_ret) + bin_len, bin_len),
...     label="dollar bars",
...     alpha=0.5,
...     density=True,
...     )
>>> plt.hist(
...     volume_bars_ret,
...     bins=np.arange(min(volume_bars_ret), max(volume_bars_ret) + bin_len, bin_len),
...     label="volume bars",
...     alpha=0.5,
...     density=True,
...     )
>>>
>>> sns.kdeplot(time_bars_ret, label="time bars", color="blue", alpha=0.5)
>>> sns.kdeplot(dollar_bars_ret, label="dollar bars", color="orange", alpha=0.5)
>>> sns.kdeplot(volume_bars_ret, label="volume bars", color="green", alpha=0.5)
>>> plt.legend()
>>> plt.show()
```

![density](images/density.png)

On the plot, it is observed a long tail on the volatility of the data, which is
characteristic of the financial market. Moreover, it is not observed a significant
difference between the volatility of the data, which means that the aggregation
techniques do not affect the volatility of the data for the IBM stocks. Further
investigation should be performed to evaluate, due to the given results are not
conclusive and differs from the expected results. For this reason, time bars will
be used for the following analysis.


### Labeling

Labeling is the process of assigning a label to each observation in the data.
In this tutorial, we will use the following labeling techniques:

- **Bollinger Bands**: The Bollinger Bands technique generates labels based on
the price of the stock and the Bollinger Bands.
- **MADC**: The MADC technique generates labels based on the price of the stock
and the MADC.
- **Triple Barrier Method**: The Triple Barrier Method technique generates labels
based on the price of the stock and the volatility of the stock.

## Meta-Labeling

Meta-labeling is the process of assigning a label to each observation in the data
based on the output of a primary model. In this tutorial, we will use the following
meta-labeling techniques:



## References

<a id="1">[1]</a>
J. Yu, K. Chang, (2020).
Neural Network Predictive Modeling on Dynamic Portfolio Management -
A Simulation-Based Portfolio Optimization Approach.
J. Risk Financial Manag. vol. 13(11), pp. 285.

<a id="2">[2]</a>
Y. Han, J. Kim, D. Enke, (2023)
A machine learning trading system for the stock market based on
N-period Min-Max labeling using XGBoost.
Expert Systems with Applications, v. 211, p. 118581.

<a id="3">[3]</a>
M. Lopez de Prado, (2017).
The 7 reasons most machine learning funds fail (presentation slides).
Social Science Research Network, Rochester, NY, SSRN Scholarly Paper ID, 3197726.

<a id="4">[4]</a>
S. Bounid, M. Oughanem, S. Boukardi, (2022).
Advanced Financial Data Processing and Labeling Methods for Machine Learning.
In: 2022 International Conference on Intelligent Systems and Computer
Vision (ISCV). IEEE. p. 1-6.

<a id="5">[5]</a>
M. Lopez de Prado, (2018).
Advances in financial machine learning. John Wiley & Sons.

<!-- \bibitem{b8} A. Singh, J. Joubert, Does meta labeling add to signal efficacy. 2019.

\bibitem{b9} P. Nousiainen, Exploration of a trading strategy system based on meta-labeling and hybrid modeling using the SigTechPlatform. 2021. -->
